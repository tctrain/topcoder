#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <functional>
#include <utility>
#include <sstream>
#include <iostream>
#include <cmath>
#include <ctime>
#include <limits>
#include <iterator>
#include <bitset>
#define sz(m)((m).size())
#define all(a)a.begin(),a.end()
#define forn(i,n)for(int i=0,i##e=n;i<i##e;++i)
#define fori(i,m)forn(i,sz(m))
#define each(i,m)for(typeof(m.begin())i=m.begin(),i##e=m.end();i!=i##e;++i)
#define srt(s)sort(all(s))
#define dump(m)copy(all(m),ostream_iterator<typeof(m[0])>(cout,"\n"));cout<<endl
using namespace std;

struct DVDPlayer {
	vector <string> findMovies(vector <string> mw) {
		string curr = mw[0];
		map<string, string> m1, m2;
		fori(i, mw) if (i != 0) m1[mw[i]] = mw[i];
		m2 = m1;
		fori(i, mw) if (i != 0) {
			string box = m2[mw[i]];
			m1[box] = curr;
			m2[curr] = box;
			curr = mw[i];
		}
		vector< pair<string, string> > v;
		each(i, m2) v.push_back(*i);
		srt(v);
		vector<string> r;
		fori(i, v) 
			if (v[i].first != curr && v[i].first != v[i].second)
				r.push_back(v[i].first + " is inside " + v[i].second + "'s case");
		return r;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	DVDPlayer *obj;
	vector <string> answer;
	obj = new DVDPlayer();
	clock_t startTime = clock();
	answer = obj->findMovies(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"citizenkane","casablanca","thegodfather"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"casablanca is inside thegodfather's case","citizenkane is inside casablanca's case"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"starwars","empirestrikesback","returnofthejedi","empirestrikesback","returnofthejedi","phantommenace","starwars"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"empirestrikesback is inside returnofthejedi's case","phantommenace is inside empirestrikesback's case","returnofthejedi is inside phantommenace's case"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"a","x","a","y","a","z","a"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You own a large selection of DVDs that you and your friends enjoy. Unfortunately, your friends aren't the most considerate bunch, so each DVD is not necessarily returned to its respective case. When your friends want to watch a movie, they go through each of your DVD cases one by one until they find the movie they want to watch. They then take that DVD out, and switch it with the one that's currently in the player.
// 
// You will be given a vector <string> moviesWatched: a list of all the movies watched in an unspecified time period, in the order they were watched. Assume you only own one copy of each movie. The DVD player is initially empty, and each DVD starts in its own case. You should return a vector <string> where each element describes a movie that is in a different movie's case after all DVDs in moviesWatched have been viewed. These elements should be of the format "<movie1> is inside <movie2>'s case". The list should be ordered alphabetically by the title of <movie1>. The last DVD in moviesWatched will still be in the DVD player at the end of the simulation, so it should never appear as <movie1> in the returned list.
// 
// DEFINITION
// Class:DVDPlayer
// Method:findMovies
// Parameters:vector <string>
// Returns:vector <string>
// Method signature:vector <string> findMovies(vector <string> moviesWatched)
// 
// 
// CONSTRAINTS
// -moviesWatched will contain between 2 and 50 elements, inclusive.
// -Each element of moviesWatched will contain between 1 and 20 characters, inclusive.
// -Each element of moviesWatched will consist of only lowercase letters ('a' - 'z').
// -No two consecutive elements of moviesWatched will be equal.
// 
// 
// EXAMPLES
// 
// 0)
// {"citizenkane", "casablanca", "thegodfather"}
// 
// Returns: {"casablanca is inside thegodfather's case", "citizenkane is inside casablanca's case" }
// 
// Your friends first remove Citizen Kane from its DVD case and put it in the player. They then look for Casablanca, find it in its own case, and swap it with the DVD in the player. Finally, they look for The Godfather, find it in its own case, and swap it with Casablanca. Note that the output is sorted alphabetically, with "casablanca" before "citizenkane".
// 
// 1)
// {"starwars", "empirestrikesback", "returnofthejedi",
//  "empirestrikesback", "returnofthejedi",
//  "phantommenace", "starwars"}
// 
// Returns: {"empirestrikesback is inside returnofthejedi's case", "phantommenace is inside empirestrikesback's case", "returnofthejedi is inside phantommenace's case" }
// 
// After the first time your friends watch Star Wars, they put it in the Empire Strikes Back DVD case. When they want to watch it the second time, they find the case that it's in and swap it with Phantom Menace, the disk currently in the DVD player. Therefore, Phantom Menace ends up in the Empire Strikes Back's case.
// 
// 2)
// {"a", "x", "a", "y", "a", "z", "a"}
// 
// Returns: { }
// 
// All movies are back in their original cases (except movie "a", which is in the DVD player).
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
