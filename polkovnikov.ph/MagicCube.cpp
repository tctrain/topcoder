#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <functional>
#include <utility>
#include <sstream>
#include <iostream>
#include <cmath>
#include <ctime>
#include <limits>
#include <iterator>
#include <bitset>
#define sz(m)((m).size())
#define all(a)a.begin(),a.end()
#define forn(i,n)for(int i=0,i##e=n;i<i##e;++i)
#define fori(i,m)forn(i,sz(m))
#define each(i,m)for(typeof(m.begin())i=m.begin(),i##e=m.end();i!=i##e;++i)
#define srt(s)sort(all(s))
#define dump(m)copy(all(m),ostream_iterator<typeof(m[0])>(cout,"\n"));cout<<endl
using namespace std;

struct MagicCube {
	int score(vector<int> v) {
		int mn = 1000, mx = 0;
		forn(i, 3) forn(j, 3) {
			int s[3] = {};
			forn(k, 3) {
				s[0] += v[i*9 + j*3 + k];
				s[1] += v[i*9 + k*3 + j];
				s[2] += v[k*9 + j*3 + i];
			}
			forn(k, 3) {
				mn = min(mn, s[k]);
				mx = max(mx, s[k]);
			}
		}
		return mx - mn;
	}
	int getScore(vector <int> nums) {
		int mn = 1000;
		fori(i, nums) forn(j, i) {
			swap(nums[i], nums[j]);
			mn = min(mn, score(nums));
			swap(nums[i], nums[j]);
		}
		return mn;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	MagicCube *obj;
	int answer;
	obj = new MagicCube();
	clock_t startTime = clock();
	answer = obj->getScore(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	
	{
	// ----- test 0 -----
	int t0[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {23,4,10,1,27,21,25,7,17,9,15,13,20,3,11,2,22,18,12,24,14,26,8,6,5,19,16};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 18;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {23,2,10,1,27,21,25,7,17,9,15,13,20,3,11,4,22,18,12,24,14,26,8,6,5,19,16};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 17;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// We've all seen magic squares before.  They are square grids full of numbers arranged so that the rows, columns and diagonals all have the same sum:
// 
//  8 1 6
//  3 5 7
//  4 9 2
// 
// In the above figure, each row, column and diagonal sums to 15.
// We'd like to extend the magic square to the magic cube.  In a magic cube, we'll ignore the diagonals, but would like the rows, columns and pillars (pillars are analogous to rows and columns, but in the third dimension) to all have the same sum.  You will be given 27 numbers that form the 27 values in a 3x3x3 cube.  The number at (i,j,k) in the cube will be represented by element i*9 + j*3 + k of the input.  
// 
// We can define the 'magic score' of a cube as the difference between the largest sum and the smallest sum (where the sums come from rows, columns, and pillars).  Your task is to try to make the cube slightly more magical by trying to decrease its magic score.  You should try to find two numbers in the cube that can be swapped to lower the cube's magic score.  You should return the minimum possible magic score of the cube after you perform one swap.  If there is no swap that would lower the magic score, return the magic score without any swaps.
// 
// DEFINITION
// Class:MagicCube
// Method:getScore
// Parameters:vector <int>
// Returns:int
// Method signature:int getScore(vector <int> nums)
// 
// 
// CONSTRAINTS
// -nums will contain exactly 27 elements, each between 1 and 100, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
// 
// Returns: 0
// 
// 1)
// {23,4,10,1,27,21,25,7,17,9,15,13,20,3,11,2,22,18,12,24,14,26,8,6,5,19,16}
// 
// Returns: 18
// 
// In the original cube, the magic score is 51-31=20.  By swapping the numbers at (0,0,1) and (1,2,0), we can improve the magic score to 51-33=18
// 
// 2)
// {23,2,10,1,27,21,25,7,17,9,15,13,20,3,11,4,22,18,12,24,14,26,8,6,5,19,16}
// 
// Returns: 17
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
