#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iterator>
#include <tuple>
#include <regex>
#include <array>
#include <valarray>
#define all(v)begin(v),end(v)
#define dump(v)copy(all(v),ostream_iterator<decltype(*begin(v))>(cout,"\n"))
#define rg(i,a,b)for(int i=a,i##e=b;i<i##e;++i)
#define fr(i,n)for(int i=0,i##e=n;i<i##e;++i)
#define rf(i,n)for(int i=n-1;i>=0;--i)
#define ei(a,m)for(auto&a:m)if(int a##i=&a-&*begin(m)+1)if(--a##i,1)
#define ec(i,m)for(int i=0,i##e=m.size();i<i##e;++i)
#define sz(v)int(v.size())
#define sr(v)sort(all(v))
#define rs(v)sort(all(v),greater<int>())
#define rev(v)reverse(all(v))
#define eb emplace_back
#define big numeric_limits<int>::max()
#define g(t,i)get<i>(t)
#define cb(v,w)copy(all(v),back_inserter(w))
#define uni(v)sort(all(v));v.erase(unique(all(v)),end(v))
#define vt(...)vector<tuple<__VA_ARGS__>>
#define smx(a,b)a=max(a,b)
#define smn(a,b)a=min(a,b)
typedef long long ll;
using namespace std;

struct PalindromeMatrix {
	int minChange(vector <string> A, int rc, int cc) {
		int w = A.size(), h = A[0].size();
		vector<int> fixr(w), fixc(h);
		fr(i, w) fr(j, h / 2) if (A[i][j] != A[i][h - 1 - j]) ++fixr[i];
		fr(j, h) fr(i, w / 2) if (A[i][j] != A[w - 1 - i][j]) ++fixc[j];
		int q = 0;
		for (;;) {
			fr(i, w) { fr(j, h) {
				cout << A[i][j] << ' ';
			} cout << endl; }
			int nr = 0, nc = 0;
			fr(i, w) if (fixr[i] == 0) ++nr;
			fr(i, h) if (fixc[i] == 0) ++nc;
			if (nr >= rc && nc >= cc) break;
			cout << 'A'; fr(i, w) cout << fixr[i] << ' '; cout << endl;
			cout << 'A'; fr(i, h) cout << fixc[i] << ' '; cout << endl;
			vector<tuple<int, int, int, int>> v;
			fr(i, w) fr(j, h) {
				int x = (A[i][j] != A[i][h - 1 - j]) + (A[i][j] != A[w - 1 - i][j]);
				int y = min(fixr[i], fixc[j]);
				if (y != 0) {
					v.eb(-x, y, i, j);
				}
			}
			sr(v);
			ei(a, v) {
				cout << -g(a,0) << ' ' << g(a,1) << ' ' << g(a,2) << ' ' << g(a,3) << endl; 
			} cout << endl;
			int a = g(v[0], 2), b = g(v[0], 3);
			if (A[a][b] != A[a][h-1-b]) {
				--fixr[a];
			}
			if (A[a][b] != A[w-1-a][b]) {
				--fixc[b]; 
			}
			A[a][b] ^= 1;
			++q;
		}
		return q;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1 << "," << p2;
	cout << "]" << endl;
	PalindromeMatrix *obj;
	int answer;
	obj = new PalindromeMatrix();
	clock_t startTime = clock();
	answer = obj->minChange(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <string> p0;
	int p1;
	int p2;
	int p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {"0000","1000","1100","1110"};
	p1 = 2;
	p2 = 2;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {"0000","1000","1100","1110"};
	p1 = 3;
	p2 = 2;
	p3 = 3;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {"01","10"};
	p1 = 1;
	p2 = 1;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {"1110","0001"};
	p1 = 0;
	p2 = 0;
	p3 = 0;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {"01010101","01010101","01010101","01010101","01010101","01010101","01010101","01010101"};
	p1 = 2;
	p2 = 3;
	p3 = 8;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {"000000000000","011101110111","010001010101","010001010101","011101010101","010101010101","010101010101","011101110111","000000000000","000000000000"};
	p1 = 5;
	p2 = 9;
	p3 = 14;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 6 -----
	disabled = false;
	p0 = {"11111101001110","11000111111111","00010101111001","10110000111111","10000011010010","10001101101101","00101010000001","10111010100100","11010011110111","11100010110110","00100101010100","01001011001000","01010001111010","10100000010011"};
	p1 = 6;
	p2 = 8;
	p3 = 31;
	all_right = (disabled || KawigiEdit_RunTest(6, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Note that the memory limit for all tasks in this SRM is 256 MB.
// 
// 
// Fox Ciel has a matrix A that consists of N rows by M columns.
// Both N and M are even.
// Each element of the matrix is either 0 or 1.
// The rows of the matrix are numbered 0 through N-1 from top to bottom, the columns are numbered 0 through M-1 from left to right.
// The element in row i, column j is denoted A(i, j).
// You are given a vector <string> A that describes the matrix A.
// The character A[i][j] is '1' if A(i, j)=1 and it is '0' otherwise.
// 
// 
// 
// A palindrome is a string that reads the same forwards and backwards.
// For example, "1001" and "0111001110" are palindromes while "1101" and "000001" are not.
// 
// 
// 
// Some rows and some columns in Ciel's matrix may be palindromes.
// For example, in the matrix below both row 0 and column 3 are palindromes.
// (Row 0 is the palindrome "0000", column 3 is the palindrome "0110".)
// 
// 
// 0000
// 0011
// 0111
// 1110
// 
// 
// 
// You are also given two ints: rowCount and columnCount.
// Ciel wants her matrix A to have at least rowCount rows that are palindromes, and at the same time at least columnCount columns that are palindromes.
// If this is currently not the case, she can change A by changing some of the elements (from '0' to '1' or vice versa).
// Compute and return the smallest possible number of elements she needs to change in order to reach her goal.
// 
// 
// DEFINITION
// Class:PalindromeMatrix
// Method:minChange
// Parameters:vector <string>, int, int
// Returns:int
// Method signature:int minChange(vector <string> A, int rowCount, int columnCount)
// 
// 
// CONSTRAINTS
// -N and M will be between 2 and 14, inclusive.
// -N and M will be even.
// -A will contain N elements.
// -Each element of A will contain M characters.
// -Each character of A will be either '0' or '1'.
// -rowCount will be between 0 and N.
// -columnCount will be between 0 and M.
// 
// 
// EXAMPLES
// 
// 0)
// {"0000"
// ,"1000"
// ,"1100"
// ,"1110"}
// 2
// 2
// 
// Returns: 1
// 
// An optimal solution is to change A(3, 0) to 0. Then we will have palindromes in two rows (0 and 3), and in two columns (0 and 3).
// 
// 1)
// {"0000"
// ,"1000"
// ,"1100"
// ,"1110"}
// 3
// 2
// 
// Returns: 3
// 
// This is similar to the previous example, but in this case we must have three row palindromes. 
// An optimal solution is to change A(1, 0), A(2, 0) and A(3, 0) to 0.
// 
// 2)
// {"01"
// ,"10"}
// 1
// 1
// 
// Returns: 1
// 
// 
// 
// 3)
// {"1110"
// ,"0001"}
// 0
// 0
// 
// Returns: 0
// 
// Here, we do not have to change A at all.
// 
// 4)
// {"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"
// ,"01010101"}
// 2
// 3
// 
// Returns: 8
// 
// 
// 
// 5)
// {"000000000000"
// ,"011101110111"
// ,"010001010101"
// ,"010001010101"
// ,"011101010101"
// ,"010101010101"
// ,"010101010101"
// ,"011101110111"
// ,"000000000000"
// ,"000000000000"}
// 5
// 9
// 
// Returns: 14
// 
// 
// 
// 6)
// {"11111101001110"
// ,"11000111111111"
// ,"00010101111001"
// ,"10110000111111"
// ,"10000011010010"
// ,"10001101101101"
// ,"00101010000001"
// ,"10111010100100"
// ,"11010011110111"
// ,"11100010110110"
// ,"00100101010100"
// ,"01001011001000"
// ,"01010001111010"
// ,"10100000010011"}
// 6
// 8
// 
// Returns: 31
// 
// 
// 
// END KAWIGIEDIT TESTING
