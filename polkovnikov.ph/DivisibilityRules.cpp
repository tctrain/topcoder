#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <functional>
#include <utility>
#include <sstream>
#include <iostream>
#include <cmath>
#include <ctime>
#include <limits>
#include <iterator>
#include <bitset>
#define sz(m)((m).size())
#define all(a)a.begin(),a.end()
#define forn(i,n)for(int i=0,i##e=n;i<i##e;++i)
#define fori(i,m)forn(i,sz(m))
#define each(i,m)for(typeof(m.begin())i=m.begin(),i##e=m.end();i!=i##e;++i)
#define srt(s)sort(all(s))
#define dump(m)copy(all(m),ostream_iterator<typeof(m[0])>(cout,"\n"));cout<<endl
using namespace std;

struct DivisibilityRules {
	vector<int> getrules(int base, int x) {
		long long m = 1;
		set<int> z;
		vector<int> r;
		for (;;) {
			r.push_back(m);
			if (z.find(m) != z.end()) break;
			z.insert(m);
			m *= base;
			m %= x;
		}
		return r;
	}
	int similar(int base, int divisor) {
		vector<int> v = getrules(base, divisor);
		int c = 0;
		forn(i, base) if (i > 1) {
			vector<int> w = getrules(base, i);
			if (v == w) ++c;
		}
		return c;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	DivisibilityRules *obj;
	int answer;
	obj = new DivisibilityRules();
	clock_t startTime = clock();
	answer = obj->similar(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 10;
	p1 = 3;
	p2 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 10;
	p1 = 5;
	p2 = 2;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 511;
	p1 = 32;
	p2 = 10;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 3;
	p1 = 2;
	p2 = 1;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 1000;
	p1 = 999;
	p2 = 7;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 655;
	p1 = 532;
	p2 = 1;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	p0 = 15;
	p1 = 4;
	all_right = KawigiEdit_RunTest(6, p0, p1, false, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Many people know that a number is divisible by 3 if and only if the sum of its digits is divisible by 3, and similarly for divisibility by 9. Some know that a number is divisible by 6 if and only if the sum of the least significant digit (the ones place) and each of the other digits times four is divisible by 6, e.g., 792 is divisible by 6 and 4*7 + 4*9 + 1*2 = 66, which is divisible by 6. Of course, this is just in base 10. It turns out that for every number, in every base, there is a "divisibility rule".
// 
// Suppose you want to find a rule for dividing by some divisor in a certain numerationBase. Raising numerationBase to the i-th power and taking the result modulo divisor, you obtain a multiplier for the i-th digit of a number. For example, in base 10, dividing by 3, we get the multipliers:
// 
// 100 % 3 = 1 % 3 = 1
// 101 % 3 = 10 % 3 = 1
// 102 % 3 = 100 % 3 = 1
// ...
// 
// so if the result is divisible by 3 when each digit is multiplied by 1, the original must have been divisible by 3 as well.
// 
// When the same multiplier is used for digit j as for digit i, with j > i, a cycle has been detected and will repeat for the remainder of the rule.
// 
// Since both 3 and 9 have the same rule in base 10, namely, "multiply each digit by 1, sum them, and check to see if the result is divisible by 3 (or 9, respectively)", you wonder whether other digits have similar divisibility rules. Determine the number of digits in numerationBase which have the same divisibility rules as divisor. A number is considered a digit in a numerationBase if it is between 0 and numerationBase - 1, inclusive, but we will exclude 0 and 1 from consideration.
// 
// DEFINITION
// Class:DivisibilityRules
// Method:similar
// Parameters:int, int
// Returns:int
// Method signature:int similar(int numerationBase, int divisor)
// 
// 
// NOTES
// -Here the 0-th digit in a number is the least significant digit, and so on.
// -The multipliers in the divisibility rule for a divisor must be less than divisor. For example, though the rule "multiply every digit by 4, sum the results, and check for divisibility by 3" would work for numerationBase 10, divisor 3, we do not consider it valid since 4 >= 3.
// -The result should always be at least 1: divisor has the same divisibility rules as divisor!
// 
// 
// CONSTRAINTS
// -numerationBase will be between 3 and 1000, inclusive.
// -divisor will be between 2 and numerationBase-1, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 10
// 3
// 
// Returns: 2
// 
// Both 3 and 9 have the same divisibility rules in base 10: multiply each digit by 1, sum the results, and check for divisibility by 3 or 9 respectively.
// 
// 1)
// 10
// 5
// 
// Returns: 2
// 
// 2 and 5 have the same divisibility rules in base 10: add 1 times the 0-th digit and 0 times the other digits; see if the result is divisible by 2 or 5 respectively.
// 
// 2)
// 511
// 32
// 
// Returns: 10
// 
// The identical rules are for digits 32, 40, 60, 80, 96, 120, 160, 240, and 480. Each has the following rule: Multiply the 0th, 2nd, 4th, 6th, etc. digits by 1, multiply the 1st, 3rd, 5th, etc. digits by 31, add the results, and check for divisibility by 32, 40, 60, 80, 96, 120, 160, 240, or 480.
// 
// 3)
// 3
// 2
// 
// Returns: 1
// 
// 4)
// 1000
// 999
// 
// Returns: 7
// 
// 5)
// 655
// 532
// 
// Returns: 1
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
